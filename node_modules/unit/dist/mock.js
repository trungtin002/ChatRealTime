"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Mock {
    /**
     * Create a Mock instance with the specified function. Proxy is automatically applied.
     * @param {*} target The target function to mock.
     * @return {Mock} A new mock class instance.
     */
    static fn(target) {
        return new Mock(target).apply();
    }
    /**
     * An empty function.
     */
    static get emptyFn() {
        return () => { };
    }
    /**
     * @param {*} target The target function to mock.
     */
    constructor(target) {
        // Ensure target is a function
        if (typeof target !== "function") {
            throw new Error("Expecting target to be a function");
        }
        this.calls = [];
        this.singleMockStack = [];
        this.pipes = [];
        this.original = target;
        this.target = target;
        // Bind proxy with the local context.
        this.proxy = this.proxy.bind(this);
    }
    /**
     * Apply the proxy to the target, permanently overriding the target function with the proxy.
     */
    apply() {
        this.target = this.proxy;
        return this;
    }
    /**
     * The invocation function that handles mocking of the target.
     * @param {Array<*>} args Arguments that will be passed to the target or mocked implementation.
     * @return {*} The returned result of the target or mocked implementation.
     */
    proxy(...args) {
        let result = undefined;
        // Create and register the call before invoking the implementation.
        const call = {
            args,
            result,
            time: Date.now()
        };
        this.calls.push(call);
        // Invoke the permanent implementation with priority.
        if (this.permanentImpl !== undefined) {
            result = this.permanentImpl(...args);
        }
        // Otherwise, invoke next mock in the stack.
        else if (this.singleMockStack.length > 0) {
            result = this.singleMockStack[0](...args);
            this.singleMockStack.splice(0, 1);
        }
        // Finally, if the single-mock stack is empty, invoke the original function.
        else {
            result = this.original(...args);
        }
        // Invoke all registered pipes.
        for (const pipe of this.pipes) {
            pipe(call);
        }
        return result;
    }
    /**
     * Mock the target's implementation once.
     * @param {MockImpl} impl The implementation.
     */
    once(impl) {
        // Permanent implementation cannot be set at this point.
        if (this.permanentImpl !== undefined) {
            throw new Error("Mock implementation has been previously locked as 'always'");
        }
        this.singleMockStack.push(impl);
        return this;
    }
    /**
     * Permanently mock the target's implementation.
     * @param {MockImpl | undefined} impl The implementation or undefined to remove permanent implementation.
     */
    always(impl) {
        this.permanentImpl = impl;
        return this;
    }
    /**
     * Mock the target's return value once.
     */
    returnOnce(result) {
        return this.once(() => result);
    }
    /**
     * Permanently mock the target's return value.
     */
    returnAlways(result) {
        return this.always(() => result);
    }
    /**
     * Register callbacks which will be invoked after the target is invoked.
     * @param {Pipe[]} callbacks The calback(s) to register.
     */
    pipe(...callbacks) {
        this.pipes.push(...callbacks);
        return this;
    }
    /**
     * Reset implementations and restore target to it's original state.
     */
    get reset() {
        this.permanentImpl = undefined;
        this.singleMockStack.length = 0;
        this.pipes.length = 0;
        return this;
    }
}
exports.default = Mock;
