"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const decorators_1 = require("../decorators");
const assert_1 = __importDefault(require("../assert"));
const is_1 = require("../is");
const runner_1 = require("../runner");
let default_1 = class default_1 {
    empty(input) {
        assert_1.default.that(input, is_1.Is.empty);
    }
    emptyString(input) {
        assert_1.default.that(input, is_1.Is.emptyString);
    }
    null(input) {
        assert_1.default.that(input, is_1.Is.null);
    }
    undefined(input) {
        assert_1.default.that(input, is_1.Is.undefined);
    }
    positive(input) {
        assert_1.default.that(input, is_1.Is.positive);
    }
    negative(input) {
        assert_1.default.that(input, is_1.Is.negative);
    }
    neutral(input) {
        assert_1.default.that(input, is_1.Is.neutral);
    }
    greaterThan(input, greaterThan) {
        assert_1.default.that(input, is_1.Is.greaterThan(greaterThan));
    }
    lessThan(input, lessThan) {
        assert_1.default.that(input, is_1.Is.lessThan(lessThan));
    }
    NaN(input) {
        assert_1.default.that(input, is_1.Is.NaN);
    }
    array(input) {
        assert_1.default.that(input, is_1.Is.array);
    }
    arrayType(input, type) {
        assert_1.default.that(input, is_1.Is.arrayOf(type));
    }
    odd(input) {
        assert_1.default.that(input, is_1.Is.odd);
    }
    even(input) {
        assert_1.default.that(input, is_1.Is.even);
    }
};
__decorate([
    decorators_1.test("Should assert whether is empty"),
    decorators_1.feed(""),
    decorators_1.feed(null),
    decorators_1.feed(undefined),
    decorators_1.feed([]),
    decorators_1.feed({}),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "empty", null);
__decorate([
    decorators_1.test("Should assert whether is empty string"),
    decorators_1.feed(""),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "emptyString", null);
__decorate([
    decorators_1.test("Should assert whether is null"),
    decorators_1.feed(null),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "null", null);
__decorate([
    decorators_1.test("Should assert whether is undefined"),
    decorators_1.feed(undefined),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "undefined", null);
__decorate([
    decorators_1.test("Should assert whether is positive"),
    decorators_1.feed(1),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "positive", null);
__decorate([
    decorators_1.test("Should assert whether is negative"),
    decorators_1.feed(-1),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "negative", null);
__decorate([
    decorators_1.test("Should assert whether is neutral"),
    decorators_1.feed(0),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "neutral", null);
__decorate([
    decorators_1.test("Should assert whether is greater than"),
    decorators_1.feed(1, 0),
    decorators_1.feed(-1, -2),
    decorators_1.feed(0, -1),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "greaterThan", null);
__decorate([
    decorators_1.test("Should assert whether is less than"),
    decorators_1.feed(0, 1),
    decorators_1.feed(-2, -1),
    decorators_1.feed(-1, 0),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number, Number]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "lessThan", null);
__decorate([
    decorators_1.test("Should assert whether is NaN"),
    decorators_1.feed(0 / 0),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "NaN", null);
__decorate([
    decorators_1.test("Should assert whether is array"),
    decorators_1.feed([]),
    decorators_1.feed([1, 2, 3]),
    decorators_1.feed([undefined, null]),
    decorators_1.feed([""]),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "array", null);
__decorate([
    decorators_1.test("Should assert whether is array of type"),
    decorators_1.feed([1, 2, 3], runner_1.JsType.Number),
    decorators_1.feed(["john", "doe"], runner_1.JsType.String),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array, String]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "arrayType", null);
__decorate([
    decorators_1.test("Should assert whether is odd"),
    decorators_1.feed(1),
    decorators_1.feed(3),
    decorators_1.feed(-1),
    decorators_1.feed(-3),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "odd", null);
__decorate([
    decorators_1.test("Should assert whether is even"),
    decorators_1.feed(0),
    decorators_1.feed(2),
    decorators_1.feed(-2),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", void 0)
], default_1.prototype, "even", null);
default_1 = __decorate([
    decorators_1.unit("Is")
], default_1);
