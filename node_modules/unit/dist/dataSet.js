"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var OmitConflictingType;
(function (OmitConflictingType) {
    OmitConflictingType[OmitConflictingType["Object"] = 0] = "Object";
    OmitConflictingType[OmitConflictingType["Array"] = 1] = "Array";
    OmitConflictingType[OmitConflictingType["Method"] = 2] = "Method";
    OmitConflictingType[OmitConflictingType["Number"] = 3] = "Number";
})(OmitConflictingType = exports.OmitConflictingType || (exports.OmitConflictingType = {}));
const ComplexTypes = [
    "function",
    "object",
    "number"
];
class DataSet {
    /**
     * Generate a conflicting data set composed of all basic JavaScript data types.
     * @param {Array<*>} exclude The types to omit from generation result.
     * @param {number} [complexity=1] The amount of parameters the target function takes. This will generate all possible combinations.
     */
    static generateConflicting(exclude, complexity = 1) {
        const params = [
            [],
            {},
            0,
            1,
            null,
            undefined,
            false,
            true,
            "test",
            "",
        ];
        if (exclude !== undefined) {
            for (const item of exclude) {
                if (!ComplexTypes.includes(typeof item) && !Array.isArray(item) && params.includes(item)) {
                    params.splice(params.indexOf(item), 1);
                }
                else if (typeof item === "number") {
                    switch (item) {
                        case OmitConflictingType.Array: {
                            // Remove 'Array'.
                            params.splice(0, 1);
                            break;
                        }
                        case OmitConflictingType.Object: {
                            // Remove 'Object'.
                            params.splice(1, 1);
                            break;
                        }
                        case OmitConflictingType.Method: {
                            // TODO.
                            throw new Error("Not yet implemented");
                        }
                        case OmitConflictingType.Number: {
                            // Remove 'Numbers'.
                            params.splice(2, 2);
                            break;
                        }
                        default: {
                            throw new Error("Unknown exclude parameter");
                        }
                    }
                }
                else {
                    throw new Error("Invalid type of item in the exclude array");
                }
            }
        }
        return params;
    }
}
exports.default = DataSet;
