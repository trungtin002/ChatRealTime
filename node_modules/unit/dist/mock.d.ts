import { Action } from "./runner";
/**
 * Represents a mock function implementation.
 */
export declare type MockImpl = (...args: any[]) => any;
/**
 * Represents a pipe callback function.
 */
export declare type Pipe = (call: ICall) => void;
/**
 * A registered function call.
 */
export interface ICall {
    readonly time: number;
    readonly args: any[];
    readonly result: any;
}
export default class Mock {
    /**
     * Create a Mock instance with the specified function. Proxy is automatically applied.
     * @param {*} target The target function to mock.
     * @return {Mock} A new mock class instance.
     */
    static fn(target: any): Mock;
    /**
     * An empty function.
     */
    static readonly emptyFn: Action;
    /**
     * The calls performed against the target function or mocked implementation.
     */
    readonly calls: ICall[];
    protected readonly singleMockStack: MockImpl[];
    protected readonly pipes: Pipe[];
    protected readonly original: any;
    protected target: any;
    protected permanentImpl?: MockImpl;
    /**
     * @param {*} target The target function to mock.
     */
    constructor(target: any);
    /**
     * Apply the proxy to the target, permanently overriding the target function with the proxy.
     */
    apply(): this;
    /**
     * The invocation function that handles mocking of the target.
     * @param {Array<*>} args Arguments that will be passed to the target or mocked implementation.
     * @return {*} The returned result of the target or mocked implementation.
     */
    proxy(...args: any[]): any;
    /**
     * Mock the target's implementation once.
     * @param {MockImpl} impl The implementation.
     */
    once(impl: MockImpl): this;
    /**
     * Permanently mock the target's implementation.
     * @param {MockImpl | undefined} impl The implementation or undefined to remove permanent implementation.
     */
    always(impl?: MockImpl): this;
    /**
     * Mock the target's return value once.
     */
    returnOnce(result: any): this;
    /**
     * Permanently mock the target's return value.
     */
    returnAlways(result: any): this;
    /**
     * Register callbacks which will be invoked after the target is invoked.
     * @param {Pipe[]} callbacks The calback(s) to register.
     */
    pipe(...callbacks: Pipe[]): this;
    /**
     * Reset implementations and restore target to it's original state.
     */
    readonly reset: this;
}
