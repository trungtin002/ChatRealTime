"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const colors_1 = __importDefault(require("colors"));
const util_1 = __importDefault(require("./util"));
const options_1 = require("./options");
const stopwatch_1 = __importDefault(require("./stopwatch"));
/**
 * Represents the various possible JavaScript entity types.
 */
var JsType;
(function (JsType) {
    JsType["Object"] = "object";
    JsType["Function"] = "function";
    JsType["String"] = "string";
    JsType["Number"] = "number";
    JsType["Undefined"] = "undefined";
    JsType["BigInteger"] = "bigint";
    JsType["Symbol"] = "symbol";
    JsType["Boolean"] = "boolean";
})(JsType = exports.JsType || (exports.JsType = {}));
class Runner {
    /**
     * Run all registered tests.
     */
    static async test(opts) {
        const options = {
            ...options_1.DefaultOpts,
            ...opts
        };
        const watch = new stopwatch_1.default();
        let firstUnit = true;
        let successful = 0;
        let count = 0;
        watch.start();
        for await (const unit of Runner.units.values()) {
            Runner.processUnit(unit, firstUnit);
            for await (const test of unit.tests) {
                if (Runner.before !== null) {
                    Runner.before();
                }
                if (await Runner.processTest(test, count === Runner.units.size - 1, options.shouldPrefix, options.measureTime)) {
                    successful++;
                }
                if (Runner.after !== null) {
                    Runner.after();
                }
                count++;
            }
            firstUnit = false;
        }
        const succeeded = successful === count;
        const timeSuffix = colors_1.default.gray(`(${watch.stop()}ms)`);
        console.log(colors_1.default.green(`\n  ${successful}/${count} {${util_1.default.percentage(successful, count)}%} passing ${timeSuffix}\n`));
        if (options.exit) {
            process.exit(succeeded ? options.successExitCode : options.failureExitCode);
        }
    }
    /**
     * Clear all registered unit tests.
     */
    static clear() {
        Runner.units.clear();
    }
    static createTest(description, unitName, instance) {
        if (Runner.units.has(unitName)) {
            const unit = Runner.units.get(unitName);
            unit.tests.push({
                description,
                instance,
                args: instance.$$unit_feed || []
            });
            return;
        }
        throw new Error(`Cannot create test | Unit '${unitName}' does not exist`);
    }
    static createUnit(name, instance) {
        Runner.units.set(name, {
            instance,
            name,
            tests: []
        });
    }
    static processUnit(unit, first = false) {
        const name = colors_1.default.cyan(`[${unit.name}]\n`);
        console.log(`${!first ? "\n" : ""}  ${name}`);
        // No tests have been defined for this unit.
        if (unit.tests.length === 0) {
            const question = colors_1.default.yellow("?");
            const desc = colors_1.default.gray("No tests defined");
            console.log(colors_1.default.yellow(`    ${question} ${desc}`));
        }
    }
    static async invokeTest(method, args) {
        let invokeResult = {
            time: 0
        };
        const watch = new stopwatch_1.default();
        watch.start();
        try {
            const result = method(...args);
            if (result instanceof Promise) {
                result.catch((error) => {
                    invokeResult.error = error;
                });
                await result;
            }
        }
        catch (error) {
            invokeResult.error = error;
        }
        invokeResult.time = watch.stop();
        return invokeResult;
    }
    static async processTest(test, isLast, shouldPrefix = false, measure = false) {
        // TODO: Inner array may still be referenced.
        let testArgs = [...test.args];
        // Always run test at least once.
        if (testArgs.length === 0) {
            testArgs = [[undefined]];
        }
        const errors = [];
        let totalTime = 0;
        // Feed all provided in-line data.
        for await (const args of testArgs) {
            const result = await Runner.invokeTest(test.instance, args);
            if (result.error !== undefined) {
                errors.push(result.error);
            }
            if (measure) {
                totalTime += result.time;
            }
        }
        const desc = colors_1.default.gray(test.description);
        const check = colors_1.default.green("âˆš");
        const fail = colors_1.default.red("X");
        // Create prefix string.
        let prefixStr = "";
        // Append target method name if applicable.
        const target = test.instance.$$unit_target;
        if (target !== undefined) {
            prefixStr += colors_1.default.bold.gray(target + "()");
        }
        // Append 'should' to the prefix if applicable.
        if (shouldPrefix) {
            // Append an extra space to separate target if applicable.
            if (target !== undefined) {
                prefixStr += " ";
            }
            prefixStr += colors_1.default.gray("Should");
        }
        // Append an extra space to separate from 'desc' if applicable.
        if (prefixStr !== "") {
            prefixStr += " ";
        }
        // Finally, create the time string.
        let timeStr = measure ? colors_1.default.gray(`${totalTime}ms `) : "";
        if (measure) {
            if (totalTime >= 3000) {
                timeStr = colors_1.default.red(timeStr);
            }
            else if (totalTime >= 1500) {
                timeStr = colors_1.default.yellow(timeStr);
            }
        }
        if (errors.length === 0) {
            console.log(`    ${timeStr}${check} ${prefixStr}${desc}`);
        }
        else {
            console.log(`    ${timeStr}${fail} ${prefixStr}${desc}\n`);
            let counter = 1;
            for (const error of errors) {
                console.log("      " + colors_1.default.gray(`${counter}. `) + colors_1.default.red(error.message));
                counter++;
            }
            if (!isLast) {
                console.log();
            }
        }
        return errors.length === 0;
    }
}
/**
 * The callback function that will be invoked before every test.
 */
Runner.before = null;
/**
 * The callback function that will be invoked after every test.
 */
Runner.after = null;
Runner.units = new Map();
exports.default = Runner;
